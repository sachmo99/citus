SET citus.next_shard_id TO 20020000;
CREATE USER functionuser;
NOTICE:  not propagating CREATE ROLE/USER commands to worker nodes
HINT:  Connect to worker nodes directly to manually create all necessary users and roles.
SELECT run_command_on_workers($$CREATE USER functionuser;$$);
      run_command_on_workers
---------------------------------------------------------------------
 (localhost,57637,t,"CREATE ROLE")
 (localhost,57638,t,"CREATE ROLE")
(2 rows)

CREATE SCHEMA function_tests AUTHORIZATION functionuser;
CREATE SCHEMA function_tests2 AUTHORIZATION functionuser;
SET search_path TO function_tests;
SET citus.shard_count TO 4;
-- test notice
CREATE TABLE notices (
    id int primary key,
    message text
);
SELECT create_distributed_table('notices', 'id');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

INSERT INTO notices VALUES (1, 'hello world');
-- Create the necessary test utility function
CREATE FUNCTION master_metadata_snapshot()
    RETURNS text[]
    LANGUAGE C STRICT
    AS 'citus';
COMMENT ON FUNCTION master_metadata_snapshot()
    IS 'commands to create the metadata snapshot';
CREATE FUNCTION notice(text)
RETURNS void
LANGUAGE plpgsql AS $$
BEGIN
    RAISE NOTICE '%', $1;
END;
$$;
SELECT create_distributed_function('notice(text)');
 create_distributed_function
---------------------------------------------------------------------

(1 row)

SELECT notice(message) FROM notices WHERE id = 1;
NOTICE:  hello world
DETAIL:  from localhost:xxxxx
 notice
---------------------------------------------------------------------

(1 row)

-- should not see a NOTICE if worker_min_messages is WARNING
SET citus.worker_min_messages TO WARNING;
SELECT notice(message) FROM notices WHERE id = 1;
 notice
---------------------------------------------------------------------

(1 row)

RESET citus.worker_min_messages;
-- Create and distribute a simple function
CREATE FUNCTION eq(macaddr, macaddr) RETURNS bool
    AS 'select $1 = $2;'
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;
CREATE FUNCTION eq8(macaddr8, macaddr8) RETURNS bool
    AS 'select $1 = $2;'
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;
-- $function$ is what postgres escapes functions with when deparsing
-- make sure $function$ doesn't cause invalid syntax
CREATE FUNCTION add_text(text, text) RETURNS text
    AS 'select $function$test$function$ || $1::int || $2::int;'
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;
CREATE FUNCTION add_polygons(polygon, polygon) RETURNS int
    AS 'select 1'
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;
-- Test some combination of functions without ddl propagation
-- This will prevent the workers from having those types created. They are
-- created just-in-time on function distribution
SET citus.enable_ddl_propagation TO off;
CREATE TYPE dup_result AS (f1 macaddr, f2 text);
CREATE FUNCTION dup(macaddr) RETURNS dup_result
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;
CREATE FUNCTION increment(int2) RETURNS int
    AS $$ SELECT $1 + 1$$
    LANGUAGE SQL;
CREATE FUNCTION eq_with_param_names(val1 macaddr, val2 macaddr) RETURNS bool
    AS 'select $1 = $2;'
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;
CREATE FUNCTION add_without_param_names(integer, integer) RETURNS integer
    AS 'select $1 + $2;'
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;
CREATE FUNCTION "eq_mi'xed_param_names"(macaddr, "va'l1" macaddr) RETURNS bool
    AS 'select $1 = $2;'
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;
-- Include aggregate function case
CREATE FUNCTION agg_sfunc(state int, item int)
RETURNS int IMMUTABLE LANGUAGE plpgsql AS $$
begin
    return state + item;
end;
$$;
CREATE FUNCTION agg_invfunc(state int, item int)
RETURNS int IMMUTABLE LANGUAGE plpgsql AS $$
begin
    return state - item;
end;
$$;
CREATE FUNCTION agg_finalfunc(state int, extra int)
RETURNS int IMMUTABLE LANGUAGE plpgsql AS $$
begin
        return state * 2;
end;
$$;
CREATE AGGREGATE sum2(int) (
    sfunc = agg_sfunc,
    stype = int,
    sspace = 8,
    finalfunc = agg_finalfunc,
    finalfunc_extra,
    initcond = '5',
    msfunc = agg_sfunc,
    mstype = int,
    msspace = 12,
    minvfunc = agg_invfunc,
    mfinalfunc = agg_finalfunc,
    mfinalfunc_extra,
    minitcond = '1',
    sortop = ">"
);
-- Test VARIADIC, example taken from postgres test suite
CREATE AGGREGATE my_rank(VARIADIC "any" ORDER BY VARIADIC "any") (
    stype = internal,
    sfunc = ordered_set_transition_multi,
    finalfunc = rank_final,
    finalfunc_extra,
    hypothetical
);
-- Test deparsing multiple parameters with names
CREATE FUNCTION agg_names_sfunc(state dup_result, x dup_result, yz dup_result)
RETURNS dup_result IMMUTABLE STRICT LANGUAGE sql AS $$
    select x.f1 | yz.f1, x.f2 || yz.f2;
$$;
CREATE FUNCTION agg_names_finalfunc(x dup_result)
RETURNS int IMMUTABLE STRICT LANGUAGE plpgsql AS $$
begin
    return x.f1;
end;
$$;
CREATE AGGREGATE agg_names(x dup_result, yz dup_result) (
    stype = dup_result,
    sfunc = agg_names_sfunc,
    finalfunc = agg_names_finalfunc,
    finalfunc_modify = shareable
);
-- make sure to propagate ddl propagation after we have setup our functions, this will
-- allow alter statements to be propagated and keep the functions in sync across machines
SET citus.enable_ddl_propagation TO on;
-- use an unusual type to force a new colocation group
CREATE TABLE statement_table(id int2);
SET citus.shard_replication_factor TO 2;
SELECT create_distributed_table('statement_table','id');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

-- create a table uses streaming-based replication (can be synced)
CREATE TABLE streaming_table(id macaddr);
SET citus.shard_replication_factor TO 1;
SELECT create_distributed_table('streaming_table','id');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

-- make sure that none of the active and primary nodes hasmetadata
-- at the start of the test
select bool_or(hasmetadata) from pg_dist_node WHERE isactive AND  noderole = 'primary';
 bool_or
---------------------------------------------------------------------
 f
(1 row)

-- if not paremeters are supplied, we'd see that function doesn't have
-- distribution_argument_index and colocationid
SELECT create_distributed_function('"eq_mi''xed_param_names"(macaddr, macaddr)');
 create_distributed_function
---------------------------------------------------------------------

(1 row)

SELECT distribution_argument_index is NULL, colocationid is NULL from citus.pg_dist_object
WHERE objid = 'eq_mi''xed_param_names(macaddr, macaddr)'::regprocedure;
 ?column? | ?column?
---------------------------------------------------------------------
 t        | t
(1 row)

-- also show that we can use the function
SELECT * FROM run_command_on_workers($$SELECT function_tests."eq_mi'xed_param_names"('0123456789ab','ba9876543210');$$) ORDER BY 1,2;
 nodename  | nodeport | success | result
---------------------------------------------------------------------
 localhost |    57637 | t       | f
 localhost |    57638 | t       | f
(2 rows)

-- make sure that none of the active and primary nodes hasmetadata
-- since the function doesn't have a parameter
select bool_or(hasmetadata) from pg_dist_node WHERE isactive AND  noderole = 'primary';
 bool_or
---------------------------------------------------------------------
 f
(1 row)

-- try to co-locate with a table that uses statement-based replication
SELECT create_distributed_function('increment(int2)', '$1');
ERROR:  cannot distribute the function "increment" since there is no table to colocate with
HINT:  Provide a distributed table via "colocate_with" option to create_distributed_function()
SELECT create_distributed_function('increment(int2)', '$1', colocate_with := 'statement_table');
ERROR:  cannot colocate function "increment" and table "statement_table"
DETAIL:  Citus currently only supports colocating function with distributed tables that are created using streaming replication model.
HINT:  When distributing tables make sure that citus.shard_replication_factor = 1
BEGIN;
DROP TABLE statement_table;
SELECT create_distributed_function('increment(int2)', '$1');
ERROR:  cannot distribute the function "increment" since there is no table to colocate with
HINT:  Provide a distributed table via "colocate_with" option to create_distributed_function()
END;
-- try to co-locate with a table that uses streaming replication
SELECT create_distributed_function('dup(macaddr)', '$1', colocate_with := 'streaming_table');
 create_distributed_function
---------------------------------------------------------------------

(1 row)

SELECT * FROM run_command_on_workers($$SELECT function_tests.dup('0123456789ab');$$) ORDER BY 1,2;
 nodename  | nodeport | success |                     result
---------------------------------------------------------------------
 localhost |    57637 | t       | (01:23:45:67:89:ab,"01:23:45:67:89:ab is text")
 localhost |    57638 | t       | (01:23:45:67:89:ab,"01:23:45:67:89:ab is text")
(2 rows)

SELECT public.wait_until_metadata_sync(30000);
 wait_until_metadata_sync
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_function('eq(macaddr,macaddr)', '$1', colocate_with := 'streaming_table');
 create_distributed_function
---------------------------------------------------------------------

(1 row)

SELECT * FROM run_command_on_workers($$SELECT function_tests.eq('012345689ab','0123456789ab');$$) ORDER BY 1,2;
 nodename  | nodeport | success | result
---------------------------------------------------------------------
 localhost |    57637 | t       | f
 localhost |    57638 | t       | f
(2 rows)

SELECT public.verify_function_is_same_on_workers('function_tests.eq(macaddr,macaddr)');
 verify_function_is_same_on_workers
---------------------------------------------------------------------
 t
(1 row)

-- distribute aggregate
SELECT create_distributed_function('sum2(int)');
 create_distributed_function
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_function('my_rank("any")');
 create_distributed_function
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_function('agg_names(dup_result,dup_result)');
 create_distributed_function
---------------------------------------------------------------------

(1 row)

-- testing alter statements for a distributed function
-- ROWS 5, untested because;
-- ERROR:  ROWS is not applicable when function does not return a set
ALTER FUNCTION eq(macaddr,macaddr) CALLED ON NULL INPUT IMMUTABLE SECURITY INVOKER PARALLEL UNSAFE LEAKPROOF COST 5;
SELECT public.verify_function_is_same_on_workers('function_tests.eq(macaddr,macaddr)');
 verify_function_is_same_on_workers
---------------------------------------------------------------------
 t
(1 row)

ALTER FUNCTION eq(macaddr,macaddr) RETURNS NULL ON NULL INPUT STABLE SECURITY DEFINER PARALLEL RESTRICTED;
SELECT public.verify_function_is_same_on_workers('function_tests.eq(macaddr,macaddr)');
 verify_function_is_same_on_workers
---------------------------------------------------------------------
 t
(1 row)

ALTER FUNCTION eq(macaddr,macaddr) STRICT VOLATILE PARALLEL SAFE;
SELECT public.verify_function_is_same_on_workers('function_tests.eq(macaddr,macaddr)');
 verify_function_is_same_on_workers
---------------------------------------------------------------------
 t
(1 row)

-- Test SET/RESET for alter function
ALTER FUNCTION eq(macaddr,macaddr) SET client_min_messages TO warning;
SELECT public.verify_function_is_same_on_workers('function_tests.eq(macaddr,macaddr)');
 verify_function_is_same_on_workers
---------------------------------------------------------------------
 t
(1 row)

ALTER FUNCTION eq(macaddr,macaddr) SET client_min_messages TO error;
SELECT public.verify_function_is_same_on_workers('function_tests.eq(macaddr,macaddr)');
 verify_function_is_same_on_workers
---------------------------------------------------------------------
 t
(1 row)

ALTER ROUTINE eq(macaddr,macaddr) SET client_min_messages TO debug;
SELECT public.verify_function_is_same_on_workers('function_tests.eq(macaddr,macaddr)');
 verify_function_is_same_on_workers
---------------------------------------------------------------------
 t
(1 row)

ALTER FUNCTION eq(macaddr,macaddr) RESET client_min_messages;
SELECT public.verify_function_is_same_on_workers('function_tests.eq(macaddr,macaddr)');
 verify_function_is_same_on_workers
---------------------------------------------------------------------
 t
(1 row)

ALTER FUNCTION eq(macaddr,macaddr) SET search_path TO 'sch'';ma', public;
SELECT public.verify_function_is_same_on_workers('function_tests.eq(macaddr,macaddr)');
 verify_function_is_same_on_workers
---------------------------------------------------------------------
 t
(1 row)

ALTER FUNCTION eq(macaddr,macaddr) RESET search_path;
-- SET ... FROM CURRENT is not supported, verify the query fails with a descriptive error irregardless of where in the action list the statement occurs
ALTER FUNCTION eq(macaddr,macaddr) SET client_min_messages FROM CURRENT;
ERROR:  unsupported ALTER FUNCTION ... SET ... FROM CURRENT for a distributed function
HINT:  SET FROM CURRENT is not supported for distributed functions, instead use the SET ... TO ... syntax with a constant value.
SELECT public.verify_function_is_same_on_workers('function_tests.eq(macaddr,macaddr)');
 verify_function_is_same_on_workers
---------------------------------------------------------------------
 t
(1 row)

ALTER FUNCTION eq(macaddr,macaddr) RETURNS NULL ON NULL INPUT SET client_min_messages FROM CURRENT;
ERROR:  unsupported ALTER FUNCTION ... SET ... FROM CURRENT for a distributed function
HINT:  SET FROM CURRENT is not supported for distributed functions, instead use the SET ... TO ... syntax with a constant value.
SELECT public.verify_function_is_same_on_workers('function_tests.eq(macaddr,macaddr)');
 verify_function_is_same_on_workers
---------------------------------------------------------------------
 t
(1 row)

ALTER FUNCTION eq(macaddr,macaddr) SET client_min_messages FROM CURRENT SECURITY DEFINER;
ERROR:  unsupported ALTER FUNCTION ... SET ... FROM CURRENT for a distributed function
HINT:  SET FROM CURRENT is not supported for distributed functions, instead use the SET ... TO ... syntax with a constant value.
SELECT public.verify_function_is_same_on_workers('function_tests.eq(macaddr,macaddr)');
 verify_function_is_same_on_workers
---------------------------------------------------------------------
 t
(1 row)

-- rename function and make sure the new name can be used on the workers while the old name can't
ALTER FUNCTION eq(macaddr,macaddr) RENAME TO eq2;
SELECT public.verify_function_is_same_on_workers('function_tests.eq2(macaddr,macaddr)');
 verify_function_is_same_on_workers
---------------------------------------------------------------------
 t
(1 row)

SELECT * FROM run_command_on_workers($$SELECT function_tests.eq('012346789ab','012345689ab');$$) ORDER BY 1,2;
 nodename  | nodeport | success |                               result
---------------------------------------------------------------------
 localhost |    57637 | f       | ERROR:  function function_tests.eq(unknown, unknown) does not exist
 localhost |    57638 | f       | ERROR:  function function_tests.eq(unknown, unknown) does not exist
(2 rows)

SELECT * FROM run_command_on_workers($$SELECT function_tests.eq2('012345689ab','012345689ab');$$) ORDER BY 1,2;
 nodename  | nodeport | success | result
---------------------------------------------------------------------
 localhost |    57637 | t       | t
 localhost |    57638 | t       | t
(2 rows)

ALTER ROUTINE eq2(macaddr,macaddr) RENAME TO eq;
ALTER AGGREGATE sum2(int) RENAME TO sum27;
SELECT * FROM run_command_on_workers($$SELECT 1 from pg_proc where proname = 'sum27';$$) ORDER BY 1,2;
 nodename  | nodeport | success | result
---------------------------------------------------------------------
 localhost |    57637 | t       | 1
 localhost |    57638 | t       | 1
(2 rows)

ALTER AGGREGATE sum27(int) RENAME TO sum2;
-- change the owner of the function and verify the owner has been changed on the workers
ALTER FUNCTION eq(macaddr,macaddr) OWNER TO functionuser;
SELECT public.verify_function_is_same_on_workers('function_tests.eq(macaddr,macaddr)');
 verify_function_is_same_on_workers
---------------------------------------------------------------------
 t
(1 row)

ALTER AGGREGATE sum2(int) OWNER TO functionuser;
ALTER ROUTINE my_rank("any") OWNER TO functionuser;
ALTER AGGREGATE my_rank("any") OWNER TO functionuser;
SELECT run_command_on_workers($$
SELECT array_agg(row(usename, nspname, proname) order by proname)
FROM pg_proc
JOIN pg_user ON (usesysid = proowner)
JOIN pg_namespace ON (pg_namespace.oid = pronamespace and nspname = 'function_tests')
WHERE proname IN ('eq', 'sum2', 'my_rank');
$$);
                                                            run_command_on_workers
---------------------------------------------------------------------
 (localhost,57637,t,"{""(functionuser,function_tests,eq)"",""(functionuser,function_tests,my_rank)"",""(functionuser,function_tests,sum2)""}")
 (localhost,57638,t,"{""(functionuser,function_tests,eq)"",""(functionuser,function_tests,my_rank)"",""(functionuser,function_tests,sum2)""}")
(2 rows)

-- change the schema of the function and verify the old schema doesn't exist anymore while
-- the new schema has the function.
ALTER FUNCTION eq(macaddr,macaddr) SET SCHEMA function_tests2;
SELECT public.verify_function_is_same_on_workers('function_tests2.eq(macaddr,macaddr)');
 verify_function_is_same_on_workers
---------------------------------------------------------------------
 t
(1 row)

SELECT * FROM run_command_on_workers($$SELECT function_tests.eq('0123456789ab','ba9876543210');$$) ORDER BY 1,2;
 nodename  | nodeport | success |                               result
---------------------------------------------------------------------
 localhost |    57637 | f       | ERROR:  function function_tests.eq(unknown, unknown) does not exist
 localhost |    57638 | f       | ERROR:  function function_tests.eq(unknown, unknown) does not exist
(2 rows)

SELECT * FROM run_command_on_workers($$SELECT function_tests2.eq('012345689ab','ba9876543210');$$) ORDER BY 1,2;
 nodename  | nodeport | success | result
---------------------------------------------------------------------
 localhost |    57637 | t       | f
 localhost |    57638 | t       | f
(2 rows)

ALTER ROUTINE function_tests2.eq(macaddr,macaddr) SET SCHEMA function_tests;
ALTER AGGREGATE sum2(int) SET SCHEMA function_tests2;
-- when a function is distributed and we create or replace the function we need to propagate the statement to the worker to keep it in sync with the coordinator
CREATE OR REPLACE FUNCTION eq(macaddr, macaddr) RETURNS bool
AS 'select $1 <> $2;' -- I know, this is not an add, but the output will tell us if the update succeeded
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;
SELECT public.verify_function_is_same_on_workers('function_tests.eq(macaddr,macaddr)');
 verify_function_is_same_on_workers
---------------------------------------------------------------------
 t
(1 row)

SELECT * FROM run_command_on_workers($$SELECT function_tests.eq('012345689ab','012345689ab');$$) ORDER BY 1,2;
 nodename  | nodeport | success | result
---------------------------------------------------------------------
 localhost |    57637 | t       | f
 localhost |    57638 | t       | f
(2 rows)

-- distributed functions should not be allowed to depend on an extension, also functions
-- that depend on an extension should not be allowed to be distributed.
ALTER FUNCTION eq(macaddr,macaddr) DEPENDS ON EXTENSION citus;
ERROR:  distrtibuted functions are not allowed to depend on an extension
DETAIL:  Function "function_tests.eq(pg_catalog.macaddr,pg_catalog.macaddr)" is already distributed. Functions from extensions are expected to be created on the workers by the extension they depend on.
SELECT create_distributed_function('pg_catalog.citus_drop_trigger()');
ERROR:  unable to create a distributed function from functions owned by an extension
DETAIL:  Function "pg_catalog.citus_drop_trigger()" has a dependency on extension "citus". Functions depending on an extension cannot be distributed. Create the function by creating the extension on the workers.
DROP FUNCTION eq(macaddr,macaddr);
-- call should fail as function should have been dropped
SELECT * FROM run_command_on_workers($$SELECT function_tests.eq('0123456789ab','ba9876543210');$$) ORDER BY 1,2;
 nodename  | nodeport | success |                               result
---------------------------------------------------------------------
 localhost |    57637 | f       | ERROR:  function function_tests.eq(unknown, unknown) does not exist
 localhost |    57638 | f       | ERROR:  function function_tests.eq(unknown, unknown) does not exist
(2 rows)

-- Test DROP for ROUTINE
CREATE OR REPLACE FUNCTION eq(macaddr, macaddr) RETURNS bool
AS 'select $1 = $2;'
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;
select create_distributed_function('eq(macaddr,macaddr)');
 create_distributed_function
---------------------------------------------------------------------

(1 row)

DROP ROUTINE eq(macaddr, macaddr);
-- call should fail as function should have been dropped
SELECT * FROM run_command_on_workers($$SELECT function_tests.eq('0123456789ab','ba9876543210');$$) ORDER BY 1,2;
 nodename  | nodeport | success |                               result
---------------------------------------------------------------------
 localhost |    57637 | f       | ERROR:  function function_tests.eq(unknown, unknown) does not exist
 localhost |    57638 | f       | ERROR:  function function_tests.eq(unknown, unknown) does not exist
(2 rows)

DROP AGGREGATE function_tests2.sum2(int);
-- call should fail as aggregate should have been dropped
SELECT * FROM run_command_on_workers('SELECT function_tests2.sum2(id) FROM (select 1 id, 2) subq;') ORDER BY 1,2;
 nodename  | nodeport | success |                            result
---------------------------------------------------------------------
 localhost |    57637 | f       | ERROR:  function function_tests2.sum2(integer) does not exist
 localhost |    57638 | f       | ERROR:  function function_tests2.sum2(integer) does not exist
(2 rows)

-- invalid distribution_arg_name
SELECT create_distributed_function('eq_with_param_names(macaddr, macaddr)', distribution_arg_name:='test');
ERROR:  cannot distribute the function "eq_with_param_names" since the distribution argument is not valid
HINT:  Either provide a valid function argument name or a valid "$paramIndex" to create_distributed_function()
SELECT create_distributed_function('eq_with_param_names(macaddr, macaddr)', distribution_arg_name:='int');
ERROR:  cannot distribute the function "eq_with_param_names" since the distribution argument is not valid
HINT:  Either provide a valid function argument name or a valid "$paramIndex" to create_distributed_function()
-- invalid distribution_arg_index
SELECT create_distributed_function('eq_with_param_names(macaddr, macaddr)', '$0');
ERROR:  cannot distribute the function "eq_with_param_names" since the distribution argument is not valid
HINT:  Either provide a valid function argument name or a valid "$paramIndex" to create_distributed_function()
SELECT create_distributed_function('eq_with_param_names(macaddr, macaddr)', '$-1');
ERROR:  cannot distribute the function "eq_with_param_names" since the distribution argument is not valid
HINT:  Either provide a valid function argument name or a valid "$paramIndex" to create_distributed_function()
SELECT create_distributed_function('eq_with_param_names(macaddr, macaddr)', '$-10');
ERROR:  cannot distribute the function "eq_with_param_names" since the distribution argument is not valid
HINT:  Either provide a valid function argument name or a valid "$paramIndex" to create_distributed_function()
SELECT create_distributed_function('eq_with_param_names(macaddr, macaddr)', '$3');
ERROR:  cannot distribute the function "eq_with_param_names" since the distribution argument is not valid
HINT:  Either provide a valid function argument name or a valid "$paramIndex" to create_distributed_function()
SELECT create_distributed_function('eq_with_param_names(macaddr, macaddr)', '$1a');
ERROR:  invalid input syntax for integer: "1a"
-- non existing column name
SELECT create_distributed_function('eq_with_param_names(macaddr, macaddr)', 'aaa');
ERROR:  cannot distribute the function "eq_with_param_names" since the distribution argument is not valid
HINT:  Either provide a valid function argument name or a valid "$paramIndex" to create_distributed_function()
-- NULL function
SELECT create_distributed_function(NULL);
ERROR:  the first parameter for create_distributed_function() should be a single a valid function or procedure name followed by a list of parameters in parantheses
HINT:  skip the parameters with OUT argtype as they are not part of the signature in PostgreSQL
-- NULL colocate_with
SELECT create_distributed_function('eq_with_param_names(macaddr, macaddr)', '$1', NULL);
ERROR:  colocate_with parameter should not be NULL
HINT:  To use the default value, set colocate_with option to "default"
-- empty string distribution_arg_index
SELECT create_distributed_function('eq_with_param_names(macaddr, macaddr)', '');
ERROR:  cannot distribute the function "eq_with_param_names" since the distribution argument is not valid
HINT:  Either provide a valid function argument name or a valid "$paramIndex" to create_distributed_function()
-- The first distributed function syncs the metadata to nodes
-- and metadata syncing is not supported within transaction blocks
BEGIN;
	SELECT create_distributed_function('eq_with_param_names(macaddr, macaddr)', distribution_arg_name:='val1');
 create_distributed_function
---------------------------------------------------------------------

(1 row)

ROLLBACK;
-- make sure that none of the nodes have the function because we've rollbacked
SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='eq_with_param_names';$$);
 run_command_on_workers
---------------------------------------------------------------------
 (localhost,57637,t,0)
 (localhost,57638,t,0)
(2 rows)

-- make sure that none of the active and primary nodes hasmetadata
select bool_or(hasmetadata) from pg_dist_node WHERE isactive AND  noderole = 'primary';
 bool_or
---------------------------------------------------------------------
 t
(1 row)

-- valid distribution with distribution_arg_name
SELECT create_distributed_function('eq_with_param_names(macaddr, macaddr)', distribution_arg_name:='val1');
 create_distributed_function
---------------------------------------------------------------------

(1 row)

-- make sure that the primary nodes are now metadata synced
select bool_and(hasmetadata) from pg_dist_node WHERE isactive AND  noderole = 'primary';
 bool_and
---------------------------------------------------------------------
 t
(1 row)

-- make sure that both of the nodes have the function because we've succeeded
SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='eq_with_param_names';$$);
 run_command_on_workers
---------------------------------------------------------------------
 (localhost,57637,t,1)
 (localhost,57638,t,1)
(2 rows)

-- valid distribution with distribution_arg_name -- case insensitive
SELECT create_distributed_function('eq_with_param_names(macaddr, macaddr)', distribution_arg_name:='VaL1');
 create_distributed_function
---------------------------------------------------------------------

(1 row)

-- show that we are able to propagate objects with multiple item on address arrays
SELECT unnest(master_metadata_snapshot()) order by 1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    unnest
---------------------------------------------------------------------
 ALTER TABLE function_tests.notices ADD CONSTRAINT notices_pkey PRIMARY KEY (id)
 ALTER TABLE function_tests.notices OWNER TO postgres
 ALTER TABLE function_tests.notices OWNER TO postgres
 ALTER TABLE function_tests.statement_table OWNER TO postgres
 ALTER TABLE function_tests.statement_table OWNER TO postgres
 ALTER TABLE function_tests.streaming_table OWNER TO postgres
 ALTER TABLE function_tests.streaming_table OWNER TO postgres
 ALTER TABLE public.table1_group1 OWNER TO postgres
 ALTER TABLE public.table1_group1 OWNER TO postgres
 ALTER TABLE public.table2_group1 OWNER TO postgres
 ALTER TABLE public.table2_group1 OWNER TO postgres
 ALTER TABLE public.table3_group2 OWNER TO postgres
 ALTER TABLE public.table3_group2 OWNER TO postgres
 ALTER TABLE public.table4_group2 OWNER TO postgres
 ALTER TABLE public.table4_group2 OWNER TO postgres
 ALTER TABLE public.table5_groupx OWNER TO postgres
 ALTER TABLE public.table5_groupx OWNER TO postgres
 ALTER TABLE test_schema_support.nation_hash OWNER TO postgres
 ALTER TABLE test_schema_support.nation_hash OWNER TO postgres
 ALTER TABLE test_schema_support.nation_hash_collation OWNER TO postgres
 ALTER TABLE test_schema_support.nation_hash_collation OWNER TO postgres
 ALTER TABLE test_schema_support.nation_hash_collation_search_path OWNER TO postgres
 ALTER TABLE test_schema_support.nation_hash_collation_search_path OWNER TO postgres
 ALTER TABLE test_schema_support.nation_hash_composite_types OWNER TO postgres
 ALTER TABLE test_schema_support.nation_hash_composite_types OWNER TO postgres
 CREATE TABLE function_tests.notices (id integer NOT NULL, message text)
 CREATE TABLE function_tests.statement_table (id smallint)
 CREATE TABLE function_tests.streaming_table (id macaddr)
 CREATE TABLE public.table1_group1 (id integer)
 CREATE TABLE public.table2_group1 (id integer)
 CREATE TABLE public.table3_group2 (id integer)
 CREATE TABLE public.table4_group2 (id integer)
 CREATE TABLE public.table5_groupx (id integer)
 CREATE TABLE test_schema_support.nation_hash (n_nationkey integer NOT NULL, n_name character(25) NOT NULL, n_regionkey integer NOT NULL, n_comment character varying(152))
 CREATE TABLE test_schema_support.nation_hash_collation (n_nationkey integer NOT NULL, n_name character(25) NOT NULL COLLATE test_schema_support.english, n_regionkey integer NOT NULL, n_comment character varying(152))
 CREATE TABLE test_schema_support.nation_hash_collation_search_path (n_nationkey integer NOT NULL, n_name character(25) NOT NULL COLLATE test_schema_support.english, n_regionkey integer NOT NULL, n_comment character varying(152))
 CREATE TABLE test_schema_support.nation_hash_composite_types (n_nationkey integer NOT NULL, n_name character(25) NOT NULL, n_regionkey integer NOT NULL, n_comment character varying(152), test_col test_schema_support.new_composite_type)
 INSERT INTO pg_dist_node (nodeid, groupid, nodename, nodeport, noderack, hasmetadata, metadatasynced, isactive, noderole, nodecluster, shouldhaveshards) VALUES (4, 1, 'localhost', 8888, 'default', FALSE, FALSE, TRUE, 'secondary'::noderole, 'default', TRUE),(5, 1, 'localhost', 8889, 'default', FALSE, FALSE, TRUE, 'secondary'::noderole, 'second-cluster', TRUE),(1380001, 1380000, 'localhost', 9000, 'default', FALSE, FALSE, TRUE, 'secondary'::noderole, 'default', TRUE),(1, 1, 'localhost', 57637, 'default', TRUE, TRUE, TRUE, 'primary'::noderole, 'default', TRUE),(1380009, 1380007, 'localhost', 57638, 'default', TRUE, TRUE, TRUE, 'primary'::noderole, 'default', TRUE)
 SELECT citus_internal_add_partition_metadata ('function_tests.notices'::regclass, 'h', 'id', 13, 'c')
 SELECT citus_internal_add_partition_metadata ('function_tests.statement_table'::regclass, 'h', 'id', 1380015, 'c')
 SELECT citus_internal_add_partition_metadata ('function_tests.streaming_table'::regclass, 'h', 'id', 1380016, 's')
 SELECT citus_internal_add_partition_metadata ('public.table1_group1'::regclass, 'h', 'id', 1000, 'c')
 SELECT citus_internal_add_partition_metadata ('public.table2_group1'::regclass, 'h', 'id', 1000, 'c')
 SELECT citus_internal_add_partition_metadata ('public.table3_group2'::regclass, 'h', 'id', 0, 'c')
 SELECT citus_internal_add_partition_metadata ('public.table4_group2'::regclass, 'h', 'id', 0, 'c')
 SELECT citus_internal_add_partition_metadata ('public.table5_groupx'::regclass, 'h', 'id', 0, 'c')
 SELECT citus_internal_add_partition_metadata ('test_schema_support.nation_hash'::regclass, 'h', 'n_nationkey', 0, 'c')
 SELECT citus_internal_add_partition_metadata ('test_schema_support.nation_hash_collation'::regclass, 'h', 'n_nationkey', 0, 'c')
 SELECT citus_internal_add_partition_metadata ('test_schema_support.nation_hash_collation_search_path'::regclass, 'h', 'n_nationkey', 0, 'c')
 SELECT citus_internal_add_partition_metadata ('test_schema_support.nation_hash_composite_types'::regclass, 'h', 'n_nationkey', 0, 'c')
 SELECT worker_create_truncate_trigger('function_tests.notices')
 SELECT worker_create_truncate_trigger('function_tests.statement_table')
 SELECT worker_create_truncate_trigger('function_tests.streaming_table')
 SELECT worker_create_truncate_trigger('public.table1_group1')
 SELECT worker_create_truncate_trigger('public.table2_group1')
 SELECT worker_create_truncate_trigger('public.table3_group2')
 SELECT worker_create_truncate_trigger('public.table4_group2')
 SELECT worker_create_truncate_trigger('public.table5_groupx')
 SELECT worker_create_truncate_trigger('test_schema_support.nation_hash')
 SELECT worker_create_truncate_trigger('test_schema_support.nation_hash_collation')
 SELECT worker_create_truncate_trigger('test_schema_support.nation_hash_collation_search_path')
 SELECT worker_create_truncate_trigger('test_schema_support.nation_hash_composite_types')
 SELECT worker_drop_distributed_table(logicalrelid::regclass::text) FROM pg_dist_partition
 TRUNCATE citus.pg_dist_object
 TRUNCATE pg_dist_node CASCADE
 WITH distributed_object_data(typetext, objnames, objargs, distargumentindex, colocationid)  AS (VALUES ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],NULL, NULL), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],NULL, NULL), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],NULL, NULL), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],NULL, NULL), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],NULL, NULL), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],NULL, NULL), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],NULL, NULL), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],NULL, NULL), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],NULL, NULL), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],NULL, NULL), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],NULL, NULL), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],NULL, NULL), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],NULL, NULL), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],NULL, NULL), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],NULL, NULL), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],0, 0), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],NULL, NULL), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],NULL, NULL), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],NULL, NULL), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],NULL, NULL), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],0, 0), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],NULL, NULL), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],NULL, NULL), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],NULL, NULL), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],NULL, NULL), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],NULL, NULL), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],NULL, NULL), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],NULL, NULL), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],NULL, NULL), ('function', ARRAY['function_tests', 'eq_with_param_names']::text[], ARRAY['pg_catalog.macaddr', 'pg_catalog.macaddr']::text[],0, 0)) SELECT citus_internal_add_object_metadata(typetext, objnames, objargs, distargumentindex::int, colocationid::int) FROM distributed_object_data;
 WITH placement_data(shardid, shardstate, shardlength, groupid, placementid)  AS (VALUES (1190003, 1, 0, 1, 53), (1190003, 1, 0, 1380007, 54), (1190005, 1, 0, 1, 57), (1190005, 1, 0, 1380007, 58)) SELECT citus_internal_add_placement_metadata(shardid, shardstate, shardlength, groupid, placementid) FROM placement_data;
 WITH placement_data(shardid, shardstate, shardlength, groupid, placementid)  AS (VALUES (1190007, 1, 0, 1, 61), (1190007, 1, 0, 1380007, 62), (1190009, 1, 0, 1, 65), (1190009, 1, 0, 1380007, 66)) SELECT citus_internal_add_placement_metadata(shardid, shardstate, shardlength, groupid, placementid) FROM placement_data;
 WITH placement_data(shardid, shardstate, shardlength, groupid, placementid)  AS (VALUES (1190011, 1, 0, 1, 69), (1190011, 1, 0, 1380007, 70), (1190013, 1, 0, 1, 73), (1190013, 1, 0, 1380007, 74)) SELECT citus_internal_add_placement_metadata(shardid, shardstate, shardlength, groupid, placementid) FROM placement_data;
 WITH placement_data(shardid, shardstate, shardlength, groupid, placementid)  AS (VALUES (1190015, 1, 0, 1, 77), (1190015, 1, 0, 1380007, 78), (1190017, 1, 0, 1, 81), (1190017, 1, 0, 1380007, 82)) SELECT citus_internal_add_placement_metadata(shardid, shardstate, shardlength, groupid, placementid) FROM placement_data;
 WITH placement_data(shardid, shardstate, shardlength, groupid, placementid)  AS (VALUES (1300001, 1, 0, 1, 244), (1300001, 1, 0, 1380007, 243), (1300003, 1, 0, 1, 248), (1300003, 1, 0, 1380007, 247)) SELECT citus_internal_add_placement_metadata(shardid, shardstate, shardlength, groupid, placementid) FROM placement_data;
 WITH placement_data(shardid, shardstate, shardlength, groupid, placementid)  AS (VALUES (1300005, 1, 0, 1, 252), (1300005, 1, 0, 1380007, 251), (1300007, 1, 0, 1, 256), (1300007, 1, 0, 1380007, 255)) SELECT citus_internal_add_placement_metadata(shardid, shardstate, shardlength, groupid, placementid) FROM placement_data;
 WITH placement_data(shardid, shardstate, shardlength, groupid, placementid)  AS (VALUES (1300009, 1, 0, 1, 260), (1300009, 1, 0, 1380007, 259), (1300011, 1, 0, 1, 264), (1300011, 1, 0, 1380007, 263)) SELECT citus_internal_add_placement_metadata(shardid, shardstate, shardlength, groupid, placementid) FROM placement_data;
 WITH placement_data(shardid, shardstate, shardlength, groupid, placementid)  AS (VALUES (1300013, 1, 0, 1, 268), (1300013, 1, 0, 1380007, 267), (1300015, 1, 0, 1, 272), (1300015, 1, 0, 1380007, 271)) SELECT citus_internal_add_placement_metadata(shardid, shardstate, shardlength, groupid, placementid) FROM placement_data;
 WITH placement_data(shardid, shardstate, shardlength, groupid, placementid)  AS (VALUES (1300017, 1, 0, 1, 276), (1300017, 1, 0, 1380007, 275), (1300019, 1, 0, 1, 280), (1300019, 1, 0, 1380007, 279)) SELECT citus_internal_add_placement_metadata(shardid, shardstate, shardlength, groupid, placementid) FROM placement_data;
 WITH placement_data(shardid, shardstate, shardlength, groupid, placementid)  AS (VALUES (20020000, 1, 0, 1, 2995), (20020000, 1, 0, 1380007, 2996), (20020001, 1, 0, 1, 2998), (20020001, 1, 0, 1380007, 2997), (20020002, 1, 0, 1, 2999), (20020002, 1, 0, 1380007, 3000), (20020003, 1, 0, 1, 3002), (20020003, 1, 0, 1380007, 3001)) SELECT citus_internal_add_placement_metadata(shardid, shardstate, shardlength, groupid, placementid) FROM placement_data;
 WITH placement_data(shardid, shardstate, shardlength, groupid, placementid)  AS (VALUES (20020004, 1, 0, 1, 3003), (20020004, 1, 0, 1380007, 3004), (20020005, 1, 0, 1, 3006), (20020005, 1, 0, 1380007, 3005), (20020006, 1, 0, 1, 3007), (20020006, 1, 0, 1380007, 3008), (20020007, 1, 0, 1, 3010), (20020007, 1, 0, 1380007, 3009)) SELECT citus_internal_add_placement_metadata(shardid, shardstate, shardlength, groupid, placementid) FROM placement_data;
 WITH placement_data(shardid, shardstate, shardlength, groupid, placementid)  AS (VALUES (20020008, 1, 0, 1, 3011), (20020009, 1, 0, 1380007, 3012), (20020010, 1, 0, 1, 3013), (20020011, 1, 0, 1380007, 3014)) SELECT citus_internal_add_placement_metadata(shardid, shardstate, shardlength, groupid, placementid) FROM placement_data;
 WITH shard_data(relationname, shardid, storagetype, shardminvalue, shardmaxvalue)  AS (VALUES ('function_tests.notices'::regclass, 20020000, 't'::"char", '-2147483648', '-1073741825'), ('function_tests.notices'::regclass, 20020001, 't'::"char", '-1073741824', '-1'), ('function_tests.notices'::regclass, 20020002, 't'::"char", '0', '1073741823'), ('function_tests.notices'::regclass, 20020003, 't'::"char", '1073741824', '2147483647')) SELECT citus_internal_add_shard_metadata(relationname, shardid, storagetype, shardminvalue, shardmaxvalue) FROM shard_data;
 WITH shard_data(relationname, shardid, storagetype, shardminvalue, shardmaxvalue)  AS (VALUES ('function_tests.statement_table'::regclass, 20020004, 't'::"char", '-2147483648', '-1073741825'), ('function_tests.statement_table'::regclass, 20020005, 't'::"char", '-1073741824', '-1'), ('function_tests.statement_table'::regclass, 20020006, 't'::"char", '0', '1073741823'), ('function_tests.statement_table'::regclass, 20020007, 't'::"char", '1073741824', '2147483647')) SELECT citus_internal_add_shard_metadata(relationname, shardid, storagetype, shardminvalue, shardmaxvalue) FROM shard_data;
 WITH shard_data(relationname, shardid, storagetype, shardminvalue, shardmaxvalue)  AS (VALUES ('function_tests.streaming_table'::regclass, 20020008, 't'::"char", '-2147483648', '-1073741825'), ('function_tests.streaming_table'::regclass, 20020009, 't'::"char", '-1073741824', '-1'), ('function_tests.streaming_table'::regclass, 20020010, 't'::"char", '0', '1073741823'), ('function_tests.streaming_table'::regclass, 20020011, 't'::"char", '1073741824', '2147483647')) SELECT citus_internal_add_shard_metadata(relationname, shardid, storagetype, shardminvalue, shardmaxvalue) FROM shard_data;
 WITH shard_data(relationname, shardid, storagetype, shardminvalue, shardmaxvalue)  AS (VALUES ('public.table1_group1'::regclass, 1300000, 't'::"char", '-2147483648', '-1073741825'), ('public.table1_group1'::regclass, 1300001, 't'::"char", '-1073741824', '-1'), ('public.table1_group1'::regclass, 1300002, 't'::"char", '0', '1073741823'), ('public.table1_group1'::regclass, 1300003, 't'::"char", '1073741824', '2147483647')) SELECT citus_internal_add_shard_metadata(relationname, shardid, storagetype, shardminvalue, shardmaxvalue) FROM shard_data;
 WITH shard_data(relationname, shardid, storagetype, shardminvalue, shardmaxvalue)  AS (VALUES ('public.table2_group1'::regclass, 1300004, 't'::"char", '-2147483648', '-1073741825'), ('public.table2_group1'::regclass, 1300005, 't'::"char", '-1073741824', '-1'), ('public.table2_group1'::regclass, 1300006, 't'::"char", '0', '1073741823'), ('public.table2_group1'::regclass, 1300007, 't'::"char", '1073741824', '2147483647')) SELECT citus_internal_add_shard_metadata(relationname, shardid, storagetype, shardminvalue, shardmaxvalue) FROM shard_data;
 WITH shard_data(relationname, shardid, storagetype, shardminvalue, shardmaxvalue)  AS (VALUES ('public.table3_group2'::regclass, 1300008, 't'::"char", '-2147483648', '-1073741825'), ('public.table3_group2'::regclass, 1300009, 't'::"char", '-1073741824', '-1'), ('public.table3_group2'::regclass, 1300010, 't'::"char", '0', '1073741823'), ('public.table3_group2'::regclass, 1300011, 't'::"char", '1073741824', '2147483647')) SELECT citus_internal_add_shard_metadata(relationname, shardid, storagetype, shardminvalue, shardmaxvalue) FROM shard_data;
 WITH shard_data(relationname, shardid, storagetype, shardminvalue, shardmaxvalue)  AS (VALUES ('public.table4_group2'::regclass, 1300012, 't'::"char", '-2147483648', '-1073741825'), ('public.table4_group2'::regclass, 1300013, 't'::"char", '-1073741824', '-1'), ('public.table4_group2'::regclass, 1300014, 't'::"char", '0', '1073741823'), ('public.table4_group2'::regclass, 1300015, 't'::"char", '1073741824', '2147483647')) SELECT citus_internal_add_shard_metadata(relationname, shardid, storagetype, shardminvalue, shardmaxvalue) FROM shard_data;
 WITH shard_data(relationname, shardid, storagetype, shardminvalue, shardmaxvalue)  AS (VALUES ('public.table5_groupx'::regclass, 1300016, 't'::"char", '-2147483648', '-1073741825'), ('public.table5_groupx'::regclass, 1300017, 't'::"char", '-1073741824', '-1'), ('public.table5_groupx'::regclass, 1300018, 't'::"char", '0', '1073741823'), ('public.table5_groupx'::regclass, 1300019, 't'::"char", '1073741824', '2147483647')) SELECT citus_internal_add_shard_metadata(relationname, shardid, storagetype, shardminvalue, shardmaxvalue) FROM shard_data;
 WITH shard_data(relationname, shardid, storagetype, shardminvalue, shardmaxvalue)  AS (VALUES ('test_schema_support.nation_hash'::regclass, 1190003, 't'::"char", '-2147483648', '-1073741825'), ('test_schema_support.nation_hash'::regclass, 1190004, 't'::"char", '-1073741824', '-1'), ('test_schema_support.nation_hash'::regclass, 1190005, 't'::"char", '0', '1073741823'), ('test_schema_support.nation_hash'::regclass, 1190006, 't'::"char", '1073741824', '2147483647')) SELECT citus_internal_add_shard_metadata(relationname, shardid, storagetype, shardminvalue, shardmaxvalue) FROM shard_data;
 WITH shard_data(relationname, shardid, storagetype, shardminvalue, shardmaxvalue)  AS (VALUES ('test_schema_support.nation_hash_collation'::regclass, 1190007, 't'::"char", '-2147483648', '-1073741825'), ('test_schema_support.nation_hash_collation'::regclass, 1190008, 't'::"char", '-1073741824', '-1'), ('test_schema_support.nation_hash_collation'::regclass, 1190009, 't'::"char", '0', '1073741823'), ('test_schema_support.nation_hash_collation'::regclass, 1190010, 't'::"char", '1073741824', '2147483647')) SELECT citus_internal_add_shard_metadata(relationname, shardid, storagetype, shardminvalue, shardmaxvalue) FROM shard_data;
 WITH shard_data(relationname, shardid, storagetype, shardminvalue, shardmaxvalue)  AS (VALUES ('test_schema_support.nation_hash_collation_search_path'::regclass, 1190011, 't'::"char", '-2147483648', '-1073741825'), ('test_schema_support.nation_hash_collation_search_path'::regclass, 1190012, 't'::"char", '-1073741824', '-1'), ('test_schema_support.nation_hash_collation_search_path'::regclass, 1190013, 't'::"char", '0', '1073741823'), ('test_schema_support.nation_hash_collation_search_path'::regclass, 1190014, 't'::"char", '1073741824', '2147483647')) SELECT citus_internal_add_shard_metadata(relationname, shardid, storagetype, shardminvalue, shardmaxvalue) FROM shard_data;
 WITH shard_data(relationname, shardid, storagetype, shardminvalue, shardmaxvalue)  AS (VALUES ('test_schema_support.nation_hash_composite_types'::regclass, 1190015, 't'::"char", '-2147483648', '-1073741825'), ('test_schema_support.nation_hash_composite_types'::regclass, 1190016, 't'::"char", '-1073741824', '-1'), ('test_schema_support.nation_hash_composite_types'::regclass, 1190017, 't'::"char", '0', '1073741823'), ('test_schema_support.nation_hash_composite_types'::regclass, 1190018, 't'::"char", '1073741824', '2147483647')) SELECT citus_internal_add_shard_metadata(relationname, shardid, storagetype, shardminvalue, shardmaxvalue) FROM shard_data;
(90 rows)

-- valid distribution with distribution_arg_index
SELECT create_distributed_function('eq_with_param_names(macaddr, macaddr)','$1');
 create_distributed_function
---------------------------------------------------------------------

(1 row)

-- a function cannot be colocated with a table that is not "streaming" replicated
SET citus.shard_replication_factor TO 2;
CREATE TABLE replicated_table_func_test (a macaddr);
SELECT create_distributed_table('replicated_table_func_test', 'a');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_function('eq_with_param_names(macaddr, macaddr)', '$1', colocate_with:='replicated_table_func_test');
ERROR:  cannot colocate function "eq_with_param_names" and table "replicated_table_func_test"
DETAIL:  Citus currently only supports colocating function with distributed tables that are created using streaming replication model.
HINT:  When distributing tables make sure that citus.shard_replication_factor = 1
SELECT public.wait_until_metadata_sync(30000);
 wait_until_metadata_sync
---------------------------------------------------------------------

(1 row)

-- a function can be colocated with a different distribution argument type
-- as long as there is a coercion path
SET citus.shard_replication_factor TO 1;
CREATE TABLE replicated_table_func_test_2 (a macaddr8);
SELECT create_distributed_table('replicated_table_func_test_2', 'a');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_function('eq_with_param_names(macaddr, macaddr)', 'val1', colocate_with:='replicated_table_func_test_2');
 create_distributed_function
---------------------------------------------------------------------

(1 row)

-- colocate_with cannot be used without distribution key
SELECT create_distributed_function('eq_with_param_names(macaddr, macaddr)', colocate_with:='replicated_table_func_test_2');
ERROR:  cannot distribute the function "eq_with_param_names" since the distribution argument is not valid
HINT:  To provide "colocate_with" option with a distributed table, the distribution argument parameter should also be provided
-- a function cannot be colocated with a local table
CREATE TABLE replicated_table_func_test_3 (a macaddr8);
SELECT create_distributed_function('eq_with_param_names(macaddr, macaddr)', 'val1', colocate_with:='replicated_table_func_test_3');
ERROR:  relation replicated_table_func_test_3 is not distributed
-- finally, colocate the function with a distributed table
SET citus.shard_replication_factor TO 1;
CREATE TABLE replicated_table_func_test_4 (a macaddr);
SELECT create_distributed_table('replicated_table_func_test_4', 'a');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_function('eq_with_param_names(macaddr, macaddr)', '$1', colocate_with:='replicated_table_func_test_4');
 create_distributed_function
---------------------------------------------------------------------

(1 row)

-- show that the colocationIds are the same
SELECT pg_dist_partition.colocationid = objects.colocationid as table_and_function_colocated
FROM pg_dist_partition, citus.pg_dist_object as objects
WHERE pg_dist_partition.logicalrelid = 'replicated_table_func_test_4'::regclass AND
	  objects.objid = 'eq_with_param_names(macaddr, macaddr)'::regprocedure;
 table_and_function_colocated
---------------------------------------------------------------------
 t
(1 row)

-- now, redistributed with the default colocation option, we should still see that the same colocation
-- group preserved, because we're using the default shard creation settings
SELECT create_distributed_function('eq_with_param_names(macaddr, macaddr)', 'val1');
 create_distributed_function
---------------------------------------------------------------------

(1 row)

SELECT pg_dist_partition.colocationid = objects.colocationid as table_and_function_colocated
FROM pg_dist_partition, citus.pg_dist_object as objects
WHERE pg_dist_partition.logicalrelid = 'replicated_table_func_test_4'::regclass AND
	  objects.objid = 'eq_with_param_names(macaddr, macaddr)'::regprocedure;
 table_and_function_colocated
---------------------------------------------------------------------
 t
(1 row)

-- a function cannot be colocated with a reference table when a distribution column is provided
SELECT create_reference_table('replicated_table_func_test_3');
 create_reference_table
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_function('eq_with_param_names(macaddr, macaddr)', 'val1', colocate_with:='replicated_table_func_test_3');
ERROR:  cannot colocate function "eq_with_param_names" and table "replicated_table_func_test_3" because distribution arguments are not supported when colocating with reference tables.
-- a function can be colocated with a reference table when the distribution argument is omitted
SELECT create_distributed_function('eq_with_param_names(macaddr, macaddr)', colocate_with:='replicated_table_func_test_3');
 create_distributed_function
---------------------------------------------------------------------

(1 row)

-- function with a macaddr8 dist. arg can be colocated with macaddr
-- column of a distributed table. In general, if there is a coercion
-- path, we rely on postgres for implicit coersions, and users for explicit coersions
-- to coerce the values
SELECT create_distributed_function('eq8(macaddr8, macaddr8)', '$1', colocate_with:='replicated_table_func_test_4');
 create_distributed_function
---------------------------------------------------------------------

(1 row)

SELECT pg_dist_partition.colocationid = objects.colocationid as table_and_function_colocated
FROM pg_dist_partition, citus.pg_dist_object as objects
WHERE pg_dist_partition.logicalrelid = 'replicated_table_func_test_4'::regclass AND
	  objects.objid = 'eq8(macaddr8, macaddr8)'::regprocedure;
 table_and_function_colocated
---------------------------------------------------------------------
 t
(1 row)

SELECT create_distributed_function('add_text(text, text)', '$1', colocate_with:='replicated_table_func_test_4');
 create_distributed_function
---------------------------------------------------------------------

(1 row)

SELECT pg_dist_partition.colocationid = objects.colocationid as table_and_function_colocated
FROM pg_dist_partition, citus.pg_dist_object as objects
WHERE pg_dist_partition.logicalrelid = 'replicated_table_func_test_4'::regclass AND
	  objects.objid = 'add_text(text, text)'::regprocedure;
 table_and_function_colocated
---------------------------------------------------------------------
 t
(1 row)

-- cannot distribute function because there is no
-- coercion path from polygon to int
SELECT create_distributed_function('add_polygons(polygon,polygon)', '$1', colocate_with:='replicated_table_func_test_4');
ERROR:  cannot colocate function "replicated_table_func_test_4" and table "add_polygons" because distribution column types don't match and there is no coercion path
-- without the colocate_with, the function errors out since there is no
-- default colocation group
SET citus.shard_count TO 55;
SELECT create_distributed_function('eq_with_param_names(macaddr, macaddr)', 'val1');
ERROR:  cannot distribute the function "eq_with_param_names" since there is no table to colocate with
HINT:  Provide a distributed table via "colocate_with" option to create_distributed_function()
-- sync metadata to workers for consistent results when clearing objects
SELECT public.wait_until_metadata_sync(30000);
 wait_until_metadata_sync
---------------------------------------------------------------------

(1 row)

SET citus.shard_replication_factor TO 1;
SET citus.shard_count TO 4;
CREATE TABLE test (id int, name text);
SELECT create_distributed_table('test','id');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

INSERT INTO test VALUES (3,'three');
CREATE OR REPLACE FUNCTION increment(int)
RETURNS NUMERIC AS $$
DECLARE ret_val NUMERIC;
BEGIN
        SELECT max(id)::numeric+1 INTO ret_val  FROM test WHERE id = $1;
        RETURN ret_val;
END;
$$  LANGUAGE plpgsql;
SELECT create_distributed_function('increment(int)', '$1', colocate_with := 'test');
 create_distributed_function
---------------------------------------------------------------------

(1 row)

-- call a distributed function inside a pl/pgsql function
CREATE OR REPLACE FUNCTION test_func_calls_dist_func()
RETURNS NUMERIC AS $$
DECLARE incremented_val NUMERIC;
BEGIN
        SELECT INTO incremented_val increment(1);
        RETURN incremented_val;
END;
$$  LANGUAGE plpgsql;
SELECT test_func_calls_dist_func();
 test_func_calls_dist_func
---------------------------------------------------------------------

(1 row)

SELECT test_func_calls_dist_func();
 test_func_calls_dist_func
---------------------------------------------------------------------

(1 row)

-- test an INSERT..SELECT via the coordinator just because it is kind of funky
INSERT INTO test SELECT increment(3);
SELECT * FROM test ORDER BY id;
 id | name
---------------------------------------------------------------------
  3 | three
  4 |
(2 rows)

DROP TABLE test;
SET client_min_messages TO error; -- suppress cascading objects dropping
DROP SCHEMA function_tests CASCADE;
DROP SCHEMA function_tests2 CASCADE;
-- clear objects
SELECT stop_metadata_sync_to_node(nodename,nodeport) FROM pg_dist_node WHERE isactive AND noderole = 'primary';
 stop_metadata_sync_to_node
---------------------------------------------------------------------


(2 rows)

-- This is hacky, but we should clean-up the resources as below
\c - - - :worker_1_port
UPDATE pg_dist_local_group SET groupid = 0;
TRUNCATE pg_dist_node;
SET client_min_messages TO error; -- suppress cascading objects dropping
DROP SCHEMA function_tests CASCADE;
DROP SCHEMA function_tests2 CASCADE;
SET search_path TO function_tests, function_tests2;
\c - - - :worker_2_port
UPDATE pg_dist_local_group SET groupid = 0;
TRUNCATE pg_dist_node;
SET client_min_messages TO error; -- suppress cascading objects dropping
DROP SCHEMA function_tests CASCADE;
DROP SCHEMA function_tests2 CASCADE;
\c - - - :master_port
DROP USER functionuser;
SELECT run_command_on_workers($$DROP USER functionuser$$);
     run_command_on_workers
---------------------------------------------------------------------
 (localhost,57637,t,"DROP ROLE")
 (localhost,57638,t,"DROP ROLE")
(2 rows)

